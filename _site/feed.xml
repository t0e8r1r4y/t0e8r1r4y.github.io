<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-05T23:55:52+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">TechLog: for Developers</title><entry><title type="html">Hands-on.Create a tech blog</title><link href="http://localhost:4000/git-blog" rel="alternate" type="text/html" title="Hands-on.Create a tech blog" /><published>2023-12-12T00:00:00+09:00</published><updated>2023-12-12T00:00:00+09:00</updated><id>http://localhost:4000/git-blog</id><content type="html" xml:base="http://localhost:4000/git-blog">&lt;h3 id=&quot;쉽지-않은-기술-블로그-만들기&quot;&gt;쉽지 않은 기술 블로그 만들기&lt;/h3&gt;

&lt;p&gt;저는 스터디 그룹을 조그마하게 꾸리고있습니다. 스터디를 하면서 정리한 내용들을 블로그로 공개하고 ‘우리가 이런 일을 하고 이런거에 관심을 가지고 있어요.’라고 자랑하고 싶은(?) 니즈가 이미 오래전부터 있었습니다. 하지만 공통적으로 사용할 기술블로그를 만드는게 쉽지는 않았습니다.&lt;/p&gt;

&lt;p&gt;첫번째 시도는 노션 공개페이지를 활용하여 블로그를 만드는 것이었습니다. 노션은 사용하기 편리하고 스터디 구성원들 간 공유는 매우 편리하고 좋았습니다. 하지만 블로그 설명에 필요한 코드와 함께 연동하여 관리하기에는 다소 부족한 느낌이 있었습니다. 그리고 관리가 조금이라도 소홀해지면 사실 노트패드 같은 느낌으로 점점 쓰게되는 것 같았습니다. 완결성있는 블로그를 작성하기가 쉽지 않았습니다. 그런 의미에서 옵시디언도 같았습니다.&lt;/p&gt;

&lt;p&gt;두번째 시도는 노션에 작성한 글을 엮어서 미디엄 블로그를 만들어보자는 것이었습니다. 코드 관련된 부분은 여전히 어려움으로 남아있었지만, git 주소를 잘 남기고 관리한다면 보다 완결성있는 글을 쓸 수 있겠다고 판단하였습니다. 하지만 이 또한 어려움이 있었는데요. 노션에 비해서 문서 편집이 어려웠고, 코드를 삽입하는 것도 외부 의존성이 필요했습니다. 그리고 폰트나 꾸밈도 제한적이었습니다. 또 공통으로 사용할 구글 계정을 파고 해당 계정을 여러 환경에서 로그인을 시도하다보니, 보안적 이슈로 계정이 잠겨버리는 일도 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;노션-페이지를-그냥-블로그에-올려-버릴-수-없을까&quot;&gt;노션 페이지를 그냥 블로그에 올려 버릴 수 없을까?&lt;/h3&gt;

&lt;p&gt;여러 시도 끝에 가장 간단한 방법은 하나의 완성된 글을 노션에다 작성하고 이 페이지를 블로그에 바로 올려버리는 것이 간편하겠다는 생각이 들었습니다.&lt;/p&gt;

&lt;p&gt;노션은 스터디 구성원들이 수년간 사용한 경험이 있기에 다른 수단에 대한 러닝 커브가 가장 낮았습니다. 그리고 여타 다른 블로그들에 비해 api가 잘 되어있어 작성한 글을 자동으로 내려 받고, 이를 다른 블로그 플랫폼에 api를 호출하여 올리기에는 최적의 글쓰기 에디터라고 판단했습니다.&lt;/p&gt;

&lt;p&gt;이제 외부에 공개할 블로그 플랫폼을 선정하여야 했습니다. 티스토리, 브런치, 미디엄 등 다양한 블로그 플랫폼이 존재하였지만, 노션에서 추출한 내용을 업로드하기에 간편하다는 생각은 들지 않았습니다. 코드와 연동하여 가장 간편한 방법이 무엇일까 고민하였을 때 github blog가 최선이라는 생각이 들었습니다.&lt;/p&gt;

&lt;p&gt;jeklly를 사용하면 github에서 모든 블로그 내용을 관리할 수 있고, 많은 공수없이 이미 만들어진 테마를 적용하여 빠르게 블로그 형태를 만들 수 있었습니다. 그리고 노션 api를 통해서 받아온 페이지 내용을 마크다운 파일 형태로 변경하여 블로그 포스트 경로에 추가해준 뒤 push만 하면 손쉽게 반영이 가능하여 발생을 위한 별도의 배포 파이프라인 구축도 불필요하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;어떻게-구축할-것인가&quot;&gt;어떻게 구축할 것인가?!&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://hissing-language-ca5.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F9fd6fd24-6311-4602-ac31-2081abcd6ece%2F7d590469-4caa-49dd-a254-a89ddbd4cf78%2FUntitled.png?table=block&amp;amp;id=c5262e9f-bbaa-43dd-a50f-dd1e3ca8d106&amp;amp;spaceId=9fd6fd24-6311-4602-ac31-2081abcd6ece&amp;amp;width=1420&amp;amp;userId=&amp;amp;cache=v2&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;전체 그림은 위와 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;글 작성은 노션에서 진행합니다.&lt;/li&gt;
  &lt;li&gt;작성된 노션글은 파이썬으로 작성된 응용프로그램을 사용하여 api 호출을 통해 내용을 가져오고, 이를 마크다운으로 작성된 형태의 파일로 만듭니다.&lt;/li&gt;
  &lt;li&gt;현재는 로컬에서 git blog 프로젝트 경로에 포스트를 저장하는 경로에 저장하도록만 구현하였습니다. 그리고 로컬에서 미리 블로그 화면을 보고 검토를 한뒤 git에 push를 하도록 구축하였습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;차후에는 운영룰을 정하고 응용프로그램을 aws와 같은 cloud 서비스에 올리므로서 자동으로 작성한 글이 post 되도록 할 예정입니다. 현재는 제 개인 기술 블로그를 위 내용으로 한번 구축해 봄으로서 필요한 내용을 아래에 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;git-blog는-어떻게-만들-것인가&quot;&gt;Git Blog는 어떻게 만들 것인가&lt;/h3&gt;

&lt;p&gt;제일먼저 필요한 것은 Git Blog의 테마라고 생각했습니다. 기본적으로 글을 어떻게 보여줄 것인지를 결정해야 했고, 노션에서 사용하는 강조 표시나 이런 부분들을 md 문법으로만 처리할 수 없기에 일부는 html style도 추가해야 했습니다. 이 부분에 대한 정확한 명세가 확정이 되어야 노션에서 추출한 게시글을 적절히 변경할 수 있다고 판단했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;https://hissing-language-ca5.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F9fd6fd24-6311-4602-ac31-2081abcd6ece%2Fe373700b-db8d-4cfa-9b6b-f73d75629650%2FUntitled.png?table=block&amp;amp;id=d93affca-115a-476f-a806-d7d10469085d&amp;amp;spaceId=9fd6fd24-6311-4602-ac31-2081abcd6ece&amp;amp;width=1920&amp;amp;userId=&amp;amp;cache=v2&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;저는 기본적인 목차형 블로그를 선택했습니다. 당연히 페이지 네이션도 적용을 해야된다고 생각했고, 글 상세 중 상단의 일부 내용을 보여 줄 수 있도록 만들었습니다. 몇개의 jeklly 테마를 조합해서 만들었습니다. 이미지의 경우 해당 레포지토리에 올릴 경우 용량의 한계가 있어 외부 cdn을 고려했습니다. 미디엄 블로그 등에 올린 포스트에서 주소만 잘 가져온다면 외부 블로그를 저장소로 사용할 수도 있다고 판단했고, 필요하다면 aws cloud front를 적절히 섞어 사용하면 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;https://hissing-language-ca5.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F9fd6fd24-6311-4602-ac31-2081abcd6ece%2F93227746-f094-40a7-83aa-71cc0470c09a%2FUntitled.png?table=block&amp;amp;id=e29e3ebf-539b-4060-9ac0-b29685950113&amp;amp;spaceId=9fd6fd24-6311-4602-ac31-2081abcd6ece&amp;amp;width=1750&amp;amp;userId=&amp;amp;cache=v2&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그리고 강조를 위한 부분은 div style을 별도로 정의하여 아래와 같이 만들었습니다. 이런 부분에서 front-end css에 대한 지식을 연마하는 기회도 되네요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;https://hissing-language-ca5.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F9fd6fd24-6311-4602-ac31-2081abcd6ece%2Ff6f31cd9-b897-4efd-af72-97b7c037f304%2FUntitled.png?table=block&amp;amp;id=04029acb-160b-4155-9e71-62e4fb13b5c4&amp;amp;spaceId=9fd6fd24-6311-4602-ac31-2081abcd6ece&amp;amp;width=1750&amp;amp;userId=&amp;amp;cache=v2&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그리고 코드와 관련된 부분은 highlight.js를 사용하였습니다. highlight.js는 적용도 간편하고 여러 디자인이 공개되어 있어 잘 적용한다면 아래와 같이 코드 가독성도 높일 수 있다고 생각했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;https://hissing-language-ca5.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F9fd6fd24-6311-4602-ac31-2081abcd6ece%2F5364f35f-c019-46b5-af4b-8f898a362cd4%2FUntitled.png?table=block&amp;amp;id=5dee0cd7-9b67-4c9e-b56a-3ac4299d8142&amp;amp;spaceId=9fd6fd24-6311-4602-ac31-2081abcd6ece&amp;amp;width=1650&amp;amp;userId=&amp;amp;cache=v2&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 페이지를 어떻게 노출할지 테마를 정하였다면 노션에서 데이터를 가져와서 변경을 할 준비가 되었습니다. 그리고 외부에 노출되는 것과 관련하여 ‘notion Google search console’ 설정을 해주어야합니다. 이를 통해 구글에서 검색 시 내 git blog 글이 노출될 되도록 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;응용-프로그램-개발에-필요한-것들&quot;&gt;응용 프로그램 개발에 필요한 것들&lt;/h3&gt;

&lt;p&gt;응용 프로그램을 개발할 언어를 선택할 때 가장 중요하게 생각했던 부분은 api 호출을 간편하게 해줄 sdk나 lib가 공식적으로 있는지를 중요하게 생각했습니다. 노션 developer 공식 문서에는 js로 예제들이 적혀 있었지만 개인적으로 &lt;a href=&quot;https://github.com/ramnes/notion-sdk-py&quot;&gt;python 공식 sdk&lt;/a&gt;가 사용이 훨씬 편리하다고 판단하여 python으로 응용프로그램을 개발하기로 결정하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;https://hissing-language-ca5.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F9fd6fd24-6311-4602-ac31-2081abcd6ece%2Fcffb292f-6c95-411c-af8f-005267211a47%2FUntitled.png?table=block&amp;amp;id=154d1668-81b6-4cf2-9e63-efe76f379276&amp;amp;spaceId=9fd6fd24-6311-4602-ac31-2081abcd6ece&amp;amp;width=1920&amp;amp;userId=&amp;amp;cache=v2&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;노션 api를 사용하기 위해서는 Integration 설정이 필요합니다. 노션 developer에서 키를 발급받아서 프로그램에서 api 호출 시 사용하면 됩니다. 그리고 페이지를 추출하기 위해서는 완결된 글 페이지에서 해당 Integration을 연동하는 작업도 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;https://hissing-language-ca5.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F9fd6fd24-6311-4602-ac31-2081abcd6ece%2Fa0c4fdd9-0514-495a-92a9-00d4db3f074f%2FUntitled.png?table=block&amp;amp;id=c9639c73-4ffd-4478-8fb6-97d41aa65468&amp;amp;spaceId=9fd6fd24-6311-4602-ac31-2081abcd6ece&amp;amp;width=1820&amp;amp;userId=&amp;amp;cache=v2&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 작업을 완료한 뒤 api로 데이터를 호출하고 응답값을 분석하여 git blog에서 정의한 스타일에 맞게 적절히 변경을 해주어야 합니다. (api 분석에 대한 부분은 노하우가 생기면 별도의 글로 올리겠습니다.) 노션의 콜아웃 같은 경우 md로 적절히 변경하기 어렵기 때문에 응용 프로그램에서 적절히 변경을 해야합니다. 이런 변경이 완료되면 해당 파일을 저장할 때 git blog 프로젝트에서 포스트 내용을 저장하는 경로에 저장을 하였습니다. 이를 push하여 블로그에 글이 자동으로 반영되도록 하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;어떤-운영룰을-만들면-좋을까&quot;&gt;어떤 운영룰을 만들면 좋을까?&lt;/h3&gt;

&lt;p&gt;저는 작성한 글에 대한 리뷰를 운영룰을 정하는게 중요하다고 생각합니다. 공통으로 사용하는 블로그라면 전체적인 주제의 방향성을 유지하는 것도 중요하고, 코드 리뷰 처럼 게시글을 꼼꼼하게 리뷰하면서 서로의 역량을 강화하는 것도 중요하겠지요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;https://hissing-language-ca5.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F9fd6fd24-6311-4602-ac31-2081abcd6ece%2F5250ead2-3467-4856-a20e-604b69c15c9d%2FUntitled.png?table=block&amp;amp;id=15eeeaa0-8607-4117-bcc3-af153fe1cbfd&amp;amp;spaceId=9fd6fd24-6311-4602-ac31-2081abcd6ece&amp;amp;width=520&amp;amp;userId=&amp;amp;cache=v2&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;블로그에 공개되는 내용은 _posts에 저장을 하고있는데 리뷰를 위해 _publication 경로를 만들어서 바로 올리지 않고, 한번 검수를 거쳐가도록 만들면 좋을 것 같습니다. PR을 올리면 글을 읽어보면서 바로바로 리뷰를 달고 이를 수정하여 _posts로 옮기면 좀 더 완성도 있는 글이 완성될 것 같습니다.&lt;/p&gt;

&lt;p&gt;그리고 차후에는 글감도 관리는 함께한다면 좀 더 완성도 있는 블로그가 되지 않을까요?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;

&lt;p&gt;스터디 기술블로그를 구축하기 위한 고민과, 이를 먼저 개인블로그에 적용시켜보면서 얻은 내용을 간략하게 정리하였습니다. 해당 내용이 좀 더 발전이 된다면 해당글을 보완하고자 합니다.&lt;/p&gt;

&lt;p&gt;최근에는 스타트업 등에서도 기술력을 알리고자 이런 블로그를 만들고 관리하는 추세입니다. 이런 내용이 조금이나마 도움이 될 수 있으면 좋겠습니다.&lt;/p&gt;</content><author><name>Jung Hyun Shin</name></author><category term="hands-on" /><category term="Hands-on experience" /><summary type="html">쉽지 않은 기술 블로그 만들기</summary></entry><entry><title type="html">Hands-on.Add a login method</title><link href="http://localhost:4000/login-part-two" rel="alternate" type="text/html" title="Hands-on.Add a login method" /><published>2023-11-10T00:00:00+09:00</published><updated>2023-11-10T00:00:00+09:00</updated><id>http://localhost:4000/login-part-two</id><content type="html" xml:base="http://localhost:4000/login-part-two">&lt;h1 id=&quot;로그인-프로세스-만들기&quot;&gt;로그인 프로세스 만들기&lt;/h1&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;문제정의&quot;&gt;문제정의&lt;/h3&gt;
&lt;h4 id=&quot;목표&quot;&gt;목표&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가  로그인을 하기 편리한 프로세스를 확립한다. 가급적 한번의 버튼 클릭으로 로그인을 할 수 있다.&lt;/li&gt;
  &lt;li&gt;데이터 분석 목적으로 사용자의 정보를 최대한 많이 수집할 수 있는 로그인 수단을 고려한다.&lt;/li&gt;
  &lt;li&gt;하나의 Auth 서버를 사용하여 여러개의 서비스를 로그인 할 수 있도록 설계한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;기대효과&quot;&gt;기대효과&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;사용자는 한번의 버튼 클릭으로 로그인을 할 수 있다.&lt;/li&gt;
  &lt;li&gt;운영 관점에서 비용을 최소화 한다.&lt;/li&gt;
  &lt;li&gt;사용자 정보를 수집하고 이를 분석하여 서비스를 개선할 수 있도록 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;개략적인-설계안-작성하기&quot;&gt;개략적인 설계안 작성하기&lt;/h3&gt;
&lt;h4 id=&quot;사용자가-로그인하기-편리한-프로세스&quot;&gt;사용자가 로그인하기 편리한 프로세스&lt;/h4&gt;
&lt;h5 id=&quot;개략적인-설계안&quot;&gt;개략적인 설계안&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가 한번의 버튼 클릭을로 로그인을 하기위해서 로그인 절차와 회원가입 절차를 구분하여 설계할지 하나의 절차로 설계할지 의사결정이 필요하다.
    &lt;ul&gt;
      &lt;li&gt;최근 서비스들의 UX를 보면 외부 Third Party Login을 제공하는 벤더사들을 활용하는 경우 로그인과 회원가입 절차를 한 흐름으로 가져간다.&lt;/li&gt;
      &lt;li&gt;이메일 인증을 통해서 회원가입을 하는 경우에는 별도의 회원가입 화면이 표시되고 이메일 인증이 되면 로그인으로 이어지는 흐름을 제공한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;개략적인 흐름을 간단하게 표현하면 아래와 같다.
&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/b088c7fa-7278-444d-a768-b329b91aa913.png?response-content-disposition=inline&amp;amp;X-Amz-Security-Token=IQoJb3JpZ2luX2VjEN3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaDmFwLW5vcnRoZWFzdC0yIkcwRQIgQtEN68Gz9RvxU3wfEAe2%2BLTnx097Rb5Bj7uEXzN3DGwCIQDHCsHi8uqtrSYjh9QaxrA4ptWlzj%2Fg1y6fHmJ%2BsjDGVirtAgin%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAEaDDMxNzkyMzcwNDg2MCIMCfgT7h4lYtOQtmLLKsEC1PO9PJ2J4p5YQvEHPVvpojSlBDkLWEpwmgcDolOWX9fIaxuCcDOLUR508gqLyzZH%2Fp7F5au6iVaPUw3rMBkRhe5vS%2F5BhFk1Pali4M%2F%2FwpLNRdzSyVUtFIJBDWkrNfopWSH7Rc9Fs%2BYWAUWfFDgk5%2BZCbSgJDdsmlhXg%2BQMsq0HZ9ZC4PdctnULnZmqYI5Gna0D6QGSWgLMSQF9DNmAcKdXT722Z6RcfzbT2K36PH2KIpMm%2BmFzi0Xpj0lST0%2B79pKVCPn4y8zY%2F2dd%2FG%2FpPJVXv85WJm8B5XMqak1GbSMFe9ovohabWEJjvWV%2FptBPz6rJhbE42FiBq5phdoXSUYvkFgNEq9pLmobKH98kH7lOVMx2PljM7EPCd%2F32%2FVZh36P%2B5HILSVUsr0LVprXoW031pRqpBmiwXSTRxTO0CTbi6MOfCg64GOrMCARd%2FUsvQ37%2FRgZ41XjBLDGsqPnZnnbO1C%2FIXrGcTauH8oco0rYhVZg9FbvfhfguGHTcDDcApBEoEmERFuUjReVfgE7hgOx3LVTWneN1RS%2BmFBTznckhcXWyep4JW2lbFdBEEn7kyI71IcqJ2fsWwa%2B3yj6OltqQ%2FXE83K6JDiFskNouF2Nrwan9tYnA5rR8mYXWNKBlz3daESz6HHlmtkemaypWIOQOqJlpWuOlRwFiv%2FcwNQ7e1B0mmLjAyI12%2FOKPOkxOgEZfEXCf1KFWGTB6wpApyYcdvFf%2F3rRYSz1nzr%2BYjHl81Lub800twQDLnEBNVmbMVXXrneqVVRRQkCDOJANin%2F3N54QMXnSwohX05b2MAGCiOYm4nV%2FuomaUu89WMK3%2FVIbVHKqxwZZFTy9Oj8A%3D%3D&amp;amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Date=20240205T141030Z&amp;amp;X-Amz-SignedHeaders=host&amp;amp;X-Amz-Expires=300&amp;amp;X-Amz-Credential=ASIAUUBN2YAODW5REC3B%2F20240205%2Fap-northeast-2%2Fs3%2Faws4_request&amp;amp;X-Amz-Signature=c9db7807aa5f969d0baa6d5d242eccec3e8a38ded089d51f5acbc930fd1d2697&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;처리 흐름
    &lt;ul&gt;
      &lt;li&gt;Web이던 App이던 Third Party Auth에 인증정보를 요청&lt;/li&gt;
      &lt;li&gt;Third Party Auth에서는 인증정보 응답&lt;/li&gt;
      &lt;li&gt;Client는 서버로 Third Party Auth에서 받은 정보 전달&lt;/li&gt;
      &lt;li&gt;Server는 Third Party Auth에 Client에서 받은 정보를 확인&lt;/li&gt;
      &lt;li&gt;검증 결과 응답&lt;/li&gt;
      &lt;li&gt;검증 결과에 따라 Clinet에 Server가 적절한 응답&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;데이터-분석목적으로-데이터-수집하기&quot;&gt;데이터 분석목적으로 데이터 수집하기&lt;/h4&gt;
&lt;h5 id=&quot;개략적인-설계안-1&quot;&gt;개략적인 설계안&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;인구 통계적 관점에서 데이터 수집
    &lt;ul&gt;
      &lt;li&gt;이름, 생년월일, 주소 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자와 커뮤니케이션 목적의 데이터 수집
    &lt;ul&gt;
      &lt;li&gt;이메일, 전화번호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Third Party Login을 사용한다면 아래의 정보를 수집할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;정보 제공 항목 ( 서버에서 요청으로 가져올 수 있는 항목 - 해당 정보는 각 디벨로퍼 센터에서 확인이 필요함 )
&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/ab6f76ea-b226-4c83-ba96-dd67a2139f66.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;고려사항&quot;&gt;고려사항&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;개인정보는 한 개인을 식별할 수 있는 고유한 정보로서 법적으로 관리가 필요한 이슈가 발생한다. 따라서 위 내용 중 관리의 이슈가 생기는 부분에 대해서는 사전고지와 해당 데이터를 관리할 책임자가 필요하다.&lt;/li&gt;
  &lt;li&gt;사이드 프로젝트에서 사용할 것이므로 최소한으로 수집할 수 있도록 데이터를 설계한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;auth-서버-공통으로-사용하기&quot;&gt;Auth 서버 공통으로 사용하기&lt;/h4&gt;
&lt;h5 id=&quot;개략적인-설계안-2&quot;&gt;개략적인 설계안&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/abb69e0b-640e-4334-9feb-78e86f667529.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 서비스에서 하나의 Auth를 쓸 수 있도록 한다.
    &lt;ul&gt;
      &lt;li&gt;여러 서비스를 동시 다발적으로 개발하여 시장에서 테스트를 하고 반영할 수 있도록 하기 위함이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;초기 설계 구현 시 사용할 인프라
    &lt;ul&gt;
      &lt;li&gt;AWS Lambda를 서버로 두고 AWS에서 인프라 사용&lt;/li&gt;
      &lt;li&gt;보안상 필요한 것들은 WAF, SHEILD 등 함께 사용
&lt;a href=&quot;https://aws.amazon.com/ko/lambda/pricing/&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;관련-기술-조사&quot;&gt;관련 기술 조사&lt;/h3&gt;
&lt;h4 id=&quot;oauth&quot;&gt;OAuth&lt;/h4&gt;
&lt;h5 id=&quot;정의&quot;&gt;정의&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Open Authorization의 약자로 인터넷 사용자들이 비밀번호를 제공하지 않고, 다른 웹사이트상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근권한을 부여할 수 있는 공통적인 수단으로 사용되는, 접근 위임을 위한 개방형 표준&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt; 인증이 아니라 인가를 제공하는 표준화된 규약이다.

불특정 다수의 클라이언트가 직접 인증을 구현하지 않고 네이버나 구글(인증 제공자)의 인증에 의존. OAuth2.0를 활용해서 이러한 인증서비스(네이버 아이디로 로그인, Google로 로그인)를 제공하고 있으며 SSO와 비슷한 효과를 얻을 수 있다. 그러나 OAuth와 SSO는 절대 같은 의미가 아니다. &lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/OAuth&quot;&gt;참고자료&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;OAuth 2.0.을 구성하는 4가지
    &lt;ul&gt;
      &lt;li&gt;Resource Owner : 리소스 소유자. 리소스 서버에 접근할 수 있도록 자격을 부여하는 주체&lt;/li&gt;
      &lt;li&gt;Client : 사용자가 사용하는 애플리케이션(웹, 앱의 형태)&lt;/li&gt;
      &lt;li&gt;Authorization Server : 권한을 관리해주는 서버. 클라이언트의 자격 접근을 확인하고 Access Token을 발급하여 권한을 부여하는 역할&lt;/li&gt;
      &lt;li&gt;Resource Server : 사용자의 보호된 자원을 관리하는 서버. AccessToken을 받고 응답을 제공함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용하는 토큰의 종류
    &lt;ul&gt;
      &lt;li&gt;Access Token : 사용자의 데이터에 접근하기 위해 필요한 자격증명. 특정 Client에 부여한 권한에 대한 정보가 담긴 문자열&lt;/li&gt;
      &lt;li&gt;Refresh Token : Access Token이 만료되었을 경우 이를 재발급하기 위한 목적.&lt;/li&gt;
      &lt;li&gt;보안의 목적으로 Access Token은 만료기간이 짧고, Refresh Token은 상대적으로 길다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;인증-방식의-종류&quot;&gt;인증 방식의 종류&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Authorization Code Grant(권한 부여 승인 방식)
    &lt;ul&gt;
      &lt;li&gt;흐름도&lt;br /&gt;
&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/131a4ff5-2359-48f4-a83c-11ffaf29400e.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Implicit Grant(암묵적 승인 방식)
    &lt;ul&gt;
      &lt;li&gt;흐름도&lt;br /&gt;
&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/d04c1186-f1cc-46d3-a097-c1fb2a9a2629.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Resource Owner Password Credentials Grant(자원 소유자 자격 증명 승인 방식)
    &lt;ul&gt;
      &lt;li&gt;흐름도&lt;br /&gt;
&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/f5eef94d-130e-4510-b5d3-249f0d267cd0.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Client Credentials Grant(클라이언트 자격 증명 승인 방식)
    &lt;ul&gt;
      &lt;li&gt;흐름도&lt;br /&gt;
&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/24237326-a523-40a4-ab30-c427ec3f629e.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;관련 링크는 아래와 같다.
&lt;a href=&quot;https://zibro.tistory.com/7&quot;&gt;참고자료&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt; 웹에서는 주로 1번 방식을 사용한다. 웹의 쿠키나 캐시는 탈취가 가능하기 때문이다. &lt;/div&gt;
&lt;div class=&quot;highlight&quot;&gt; 앱서비스는 2,3,4의 흐름을 주로 가진다. 앱 자체에서 사용되는 sdk에서 Thrid party login을 제공하는 벤더사들 Auth 서버와 통신을 하여 이미 클라이언트 레벨에서 인증이 완료가 되고 그 인증 정보를 가지고 서버는 다시금 확인 절차만 가져가기 때문이다. &lt;/div&gt;

&lt;h5 id=&quot;oauth-로그인을-제공하는-회사들의-인증-방식-및-제공정보&quot;&gt;OAuth 로그인을 제공하는 회사들의 인증 방식 및 제공정보&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;주요 로그인 수단
    &lt;ul&gt;
      &lt;li&gt;네이버
        &lt;ul&gt;
          &lt;li&gt;네이버 디벨로퍼 센터
&lt;a href=&quot;https://developers.naver.com/docs/login/devguide/devguide.md#3-4-4-접근-토큰-발급-요청&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;카카오
        &lt;ul&gt;
          &lt;li&gt;카카오 디벨로퍼 센터
&lt;a href=&quot;https://developers.kakao.com/&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;페이코 인증 서비스&lt;/li&gt;
      &lt;li&gt;애플
        &lt;ul&gt;
          &lt;li&gt;다른 회사와 다르게 OAuth 인증 Flow가 조금 다르다. 위 조사한 종류에서 암묵적 인증 방식을 따르는 것으로 보인다.&lt;/li&gt;
          &lt;li&gt;그래서 개인 프로젝트에서는 firebase auth에 수단을 추가하고 그것을 기준으로 처리하는 흐름으로 가져갔다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;구글
        &lt;ul&gt;
          &lt;li&gt;특징
            &lt;ul&gt;
              &lt;li&gt;rest api와 firebase auth의 인증방식이 유사하기에 관련된 값들만 있다면 두 인증방식을 동시에 사용 할 수 있다.&lt;/li&gt;
              &lt;li&gt;사용하기에 한국어 레퍼런스가 많아서 손쉽게 정보를 구하고 쓸 수 있다.&lt;/li&gt;
              &lt;li&gt;스프링부트 프로젝트에서 firebas auth dependenciies는 아래와 같이 추가할 수 있다.&lt;/li&gt;
              &lt;li&gt;문서가 구글 디벨로퍼, 파이어베이스 문서 등 내용이 조금 산재되어있고, OAuth 관련 내용의 이해가 조금 부족하다면 혼선이 올 수 있다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;파이어 베이스
&lt;a href=&quot;https://firebase.google.com/docs/admin/setup?hl=ko#java&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;구글 디벨로퍼 센터
&lt;a href=&quot;https://developers.google.com/?hl=ko&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;페이스북(메타)
        &lt;ul&gt;
          &lt;li&gt;메타 디벨로퍼 센터
&lt;a href=&quot;https://developers.facebook.com/docs/facebook-login/guides/access-tokens#extending&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;라인
        &lt;ul&gt;
          &lt;li&gt;라인 디벨로퍼 센터
&lt;a href=&quot;https://developers.line.biz/en/&quot;&gt;참고자료&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;국내 제공 회사들은 조금 더 많은 사용자 정보를 제공하는 경향이 있다. 물론 사용자 정보 제공 동의를 하지 않는다면 클라리언트나 서버에서 조회할 기회는 없지만, 사용성을 고려했을 때 노출되는 빈도가 훨씬 높다.&lt;/li&gt;
      &lt;li&gt;회사들 마다 차이는 있지만 Refresh Token 관리 정책은 차이가 존재한다. 해당 정보를 모든 Response 마다 제공하지 않거나, 관련 처리 자체를 자기네들이 하는 경우도 있다.&lt;/li&gt;
      &lt;li&gt;대부분 로그인 수단을 구현해본바, 로그인 프로세스 설계(기획적인 절차 포함)에 따라 적절히 관련 기술을 활용하면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h4 id=&quot;더-알아보면-좋은-웹-보안-sso&quot;&gt;더 알아보면 좋은 웹 보안 SSO&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;주요-용어-정리&quot;&gt;주요 용어 정리&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;SSO : Single Sign On&lt;/li&gt;
  &lt;li&gt;SAML : Security Assertion Markup Language&lt;/li&gt;
  &lt;li&gt;OAuth2 : Open Authorization 2&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;sso의-장점&quot;&gt;SSO의 장점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;한 세트의 인증정보만으로 연관된 모든 사이트에 접근할 수 있기때문에 보안관리 측면에서 사용자경험을 개선&lt;/li&gt;
  &lt;li&gt;기존에 여러 곳에서 분산되어 관리되던 인증정보가 한 곳으로 집중되기 때문에 보안을 강화하기가 수월&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;cookie-기반-sso&quot;&gt;Cookie 기반 SSO&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;과거엔 Cookie를 이용하여 SSO를 구현했다고 한다. 하지만 여러가지 한계점이 존재했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;saml이란-&quot;&gt;SAML이란 ?&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IdP(ID 공급자)와 SP(서비스 공급자) 간 인증정보를 교환하기 위한 마크업 언어
&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/1fbeb4b6-6455-4b0d-ac88-05dfdc89aafe.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;항공기 탑승과정을 통해 이해하는 SAML&lt;/li&gt;
  &lt;li&gt;항공기에 탑승하기 전에 항공사는 다른 승객의 보안을 보장하기 위해 귀하가 누구인지 확인해야 합니다. 따라서 정부에서 발급한 신분증으로 신원을 확인합니다. 신분증의 이름이 항공권의 이름과 일치하는지 확인하면 비행기에 탑승할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;위의 예에서 정부는 ID 제공자이고 항공사는 서비스 제공자입니다. &lt;/li&gt;
  &lt;li&gt;정부에서 발급한 신분증은 SAML Assertion입니다. 정부 ID를 신청할 때 일반적으로 양식을 작성하고 사진을 찍어야 하며 경우에 따라 지문도 찍어야 합니다. 그런 다음 정부(ID 제공자)는 이러한 식별 속성을 데이터베이스에 저장하고 귀하의 신원과 관련된 실제 ID를 발급합니다. &lt;/li&gt;
  &lt;li&gt;탑승구에 도착하면 항공사(서비스 제공업체)가 사용자의 신분증( SAML Assertion )을 확인합니다. 항공사는 귀하의 세부 정보가 포함된 귀하의 신분증을 받아 유효성 검사를 실시합니다. 모든 절차가 끝나고 인증에 성공하면 항공사(서비스 제공업체)에서 항공기 탑승(서비스 이용)을 허용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;saml-sso의-워크플로우-이해&quot;&gt;SAML SSO의 워크플로우 이해&lt;/h5&gt;
&lt;h5 id=&quot;idpid-공급자-initiated&quot;&gt;IdP(ID 공급자) Initiated&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/3ebf03bf-6e39-4533-94b0-5503b355a26d.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자는 IdP에 먼저 접속 및 로그인&lt;/li&gt;
  &lt;li&gt;인증 완료시 IdP는 SP에게 SAML Response 전달&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;sp서비스-공급자-initiated&quot;&gt;SP(서비스 공급자) Initiated&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/5fbdef24-39fc-4b9a-93c4-cb412417ed43.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자가 SP의 서비스를 이용하기 위해 Access&lt;/li&gt;
  &lt;li&gt;SP는 사용자가 현재 미인증 상태임을 확인하고 IdP로 User를 Redirect(이때 사용자는 SAML Request를 하게 됨)&lt;/li&gt;
  &lt;li&gt;IdP는 필요한 경우 사용자에게 자격증명을 요청 (이미 인증된 경우 생략)&lt;/li&gt;
  &lt;li&gt;사용자는 IdP에 로그인&lt;/li&gt;
  &lt;li&gt;IdP는 SAML Response을 생성하여 사용자의 브라우저에 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;saml-예제-코드-분석&quot;&gt;SAML 예제 코드 분석&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;IdP
    &lt;ul&gt;
      &lt;li&gt;SamlIdpApplication : 메인, 진입점&lt;/li&gt;
      &lt;li&gt;WebSecurityConfigurer : Spring Security 설정 파일&lt;/li&gt;
    &lt;/ul&gt;
    &lt;pre&gt;
  &lt;code class=&quot;plain text&quot;&gt;
  설정 내용 
  - 디폴트 유저 생성(DB가 따로 없음)
  - 페이지별 권한 세팅(스프링 시큐리티 기본기능)
  - SAML 응답을 위한 Filter 추가
  - KeyStoreLocator를 통해 동적으로 KeyStore 생성
  &lt;/code&gt;
&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;AbstractSamlPrincipalFactory, LocalSamlPrincipalFactory, SamlPrincipal
    &lt;pre&gt;
  &lt;code class=&quot;java&quot;&gt;
    //SP에게 전달받은 authnRequest(인증요청)으로부터 
    //SamlPrincipal을 생성하는 역할

    public SamlPrincipal createSamlPrincipal(@SuppressWarnings(&quot;rawtypes&quot;) SAMLMessageContext messageContext,
                                            Authentication authentication) {
        AuthnRequest authnRequest = (AuthnRequest) messageContext.getInboundSAMLMessage();
        List&amp;lt; SamlAttribute&amp;gt; attributes = createAttributes(authentication);
        return SamlPrincipal.builder(authentication.getName(), nameIdType, attributes)
                            .serviceProviderEntityID(authnRequest.getIssuer().getValue())
                            .requestID(authnRequest.getID())
                            .assertionConsumerServiceUrl(authnRequest.getAssertionConsumerServiceURL())
                            .relayState(messageContext.getRelayState())
                            .build();
    }
    //템플릿 메소드 패턴을 이용하여 Saml속성을 Create하는 부분을 추상화.
    protected abstract List&amp;lt; SamlAttribute&amp;gt; createAttributes(Authentication authentication)
  &lt;/code&gt;
&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;SamlMessageHandler
    &lt;pre&gt;
  &lt;code class=&quot;java&quot;&gt;
    //핵심역할 : authnRequest(인증요청)을 파싱, SamlResponse를 전송

    //실제 SamlResponse의 내용을 생성하는 역할은 SamlBuilder가 한다. 
    import static saml.example.idp.SamlBuilder.buildAssertion;
    import static saml.example.idp.SamlBuilder.buildIssuer;
    import static saml.example.idp.SamlBuilder.buildSAMLObject;
    import static saml.example.idp.SamlBuilder.buildStatus;
    import static saml.example.idp.SamlBuilder.signAssertion;

    //시그니쳐만 명시
    public SAMLMessageContext extractSAMLMessageContext(HttpServletRequest request,
                                                            HttpServletResponse response)
                throws ValidationException, SecurityException, MessageDecodingException

    //시그니쳐만 명시
    public void sendAuthnResponse(SamlPrincipal principal, HttpServletResponse response)
                throws MarshallingException, SignatureException, MessageEncodingException
  &lt;/code&gt;
&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;SamlResponseFilter
    &lt;pre&gt;
  &lt;code class=&quot;java&quot;&gt;
    //역할: 인증워크로드 정의 
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException {
        try {
            if (!request.getRequestURI().startsWith(ssoUrl)) {
                filterChain.doFilter(request, response);
                return;
            }
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            if (isNull(authentication)
                    || authentication instanceof AnonymousAuthenticationToken
                    || !authentication.isAuthenticated()) {
                filterChain.doFilter(request, response);
                return;
            }
            @SuppressWarnings(&quot;rawtypes&quot;)
            SAMLMessageContext messageContext = samlMessageHandler.extractSAMLMessageContext(request, response);
            SamlPrincipal principal = samlPrincipalFactory.createSamlPrincipal(messageContext, authentication);
            samlMessageHandler.sendAuthnResponse(principal, response);
        } catch (Exception e) {
            throw new ServletException(&quot;Failed to send saml response.&quot;, e);
        }
    }
  &lt;/code&gt;
&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;SP
    &lt;ul&gt;
      &lt;li&gt;SamlSpApplication : 메인, 진입점&lt;/li&gt;
      &lt;li&gt;WebSecurityConfigurer : Spring Security 설정 파일&lt;/li&gt;
    &lt;/ul&gt;
    &lt;pre&gt;
  &lt;code class=&quot;plain text&quot;&gt;
    설정 내용 
    - 페이지별 권한 세팅(스프링 시큐리티 기본기능)
    - 인증 제공자로 SamlAuthenticationProvider 지정
    - 인증 진입점으로 SamlSsoEntryPoint 지정
    - SamlAssertionConsumeFilter를 보안필터로 추가
  &lt;/code&gt;
&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;SamlSsoEntryPoint  : 진입점
    &lt;pre&gt;
  &lt;code class=&quot;java&quot;&gt;
  //역할 : SAML 요청을 생성한 후 IdP로 Redirect 시킴 
  //redirect URL 
  // http://localhost:9105/sso?SAMLRequest=fZFfa8IwFMXf9ylK3mObVGsNtuI2ZIJjRese9pbG6wy0ictNZfv2U6swYfh4L%2BfcP78znnw3dXAAh9qajLBeRAIwym60%2BczIupzRlEzyhzHKpuZ7MW39zizhqwX0wRQRnD%2F6nqzBtgG3AnfQCtbLRUZ23u9FGNZWyXpn0YsRi5JQKiTB%2FDkjMYvTJN0CTUEmtN8fDmg1YIxWCiKWxsMtqOqoxEIi6gNkxLsWTg1sYW7QS%2BMzwiPOKIsoY2XUF4NY8GEvGfEPEhTOeqts%2FahN90nrjLASNQojG0DhlVhNXxeC9yJRdSIUL2VZ0OJtVZLg%2FUqEn4gcGRkUHYP7s%2FaXxSTvkInzxS6YWddIf9976ugN3Z6lAozX%2Fudm9327vMZB8n%2Fhj8O%2FF%2BWX8jbT%2FBc%3D
  &lt;/code&gt;
&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;SamlAssertionConsumeFilter
    &lt;pre&gt;
  &lt;code class=&quot;java&quot;&gt;
    //역할 : SAML 응답을 통해 인증을 처리하는 워크로드 정의
    //IdP로 부터 이미 응답을 전달 받은 상태
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)
            throws AuthenticationException {
        LOGGER.debug(&quot;Attempt authentication...&quot;);
        //samlContextProvider를 통해 samlContext 가져옴
        SamlContext samlContext = samlContextProvider.getLocalContext(request, response);
        SamlPreAuthenticationToken token = new SamlPreAuthenticationToken(samlContext);
        return getAuthenticationManager().authenticate(token);
    }
  &lt;/code&gt;
&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;SamlAuthenticationProvider
    &lt;pre&gt;
  &lt;code class=&quot;java&quot;&gt;//역할 : 인증 로직 처리
    @Override
    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        SamlPreAuthenticationToken preAuthenticationToken = (SamlPreAuthenticationToken) authentication;
        SamlContext samlContext = preAuthenticationToken.samlContext();
        @SuppressWarnings(&quot;rawtypes&quot;) SAMLMessageContext messageContext = null;
        try {
            messageContext = extractSAMLMessageContext(samlContext.request());
        } catch (MessageDecodingException | SecurityException e) {
            LOGGER.error(&quot;Failed to decode saml request&quot;, e);
            throw new InternalAuthenticationServiceException(&quot;Failed to decode saml request&quot;, e);
        }
        //saml 응답 가져오기 
        Response samlResponse = (Response) messageContext.getInboundSAMLMessage();
          
        //로그인 성공 여부 확인
        String statusCode = samlResponse.getStatus().getStatusCode().getValue();
        if (!StatusCode.SUCCESS_URI.equals(statusCode)) {
            LOGGER.error(&quot;SAML login failed. status code[{}]&quot;, statusCode);
            throw new AuthenticationServiceException(&quot;SAML response status fail, code[&quot; + statusCode + &quot;]&quot;);
        }
        //assertionConsumer를 통해 userDetail 생성
        UserDetails userDetails = assertionConsumer.consume(samlResponse);
        LOGGER.info(&quot;Login user[{}]&quot;, userDetails);
        List&amp;lt; GrantedAuthority&amp;gt; authorities = AuthorityUtils.createAuthorityList(&quot;ROLE_USER&quot;); // for test!!

        //인증완료 처리
        SamlAuthenticationToken resultToken = new SamlAuthenticationToken(userDetails.getUsername(), authorities);
        resultToken.setAuthenticated(true);
        resultToken.setDetails(userDetails);

        return resultToken;
    }
  &lt;/code&gt;
&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;SimpleSamlAssertionConsumer
    &lt;pre&gt;
  &lt;code class=&quot;java&quot;&gt;
    //역할 : SAML 응답을 전달받아 UserDetail 생성 
    public UserDetails consume(Response samlResponse) throws AuthenticationException {
        validateSignature(samlResponse);
        checkAuthnInstant(samlResponse);
        Assertion assertion = samlResponse.getAssertions().get(0);
        LOGGER.debug(&quot;Assertion[{}]&quot;, SamlUtil.samlObjectToString(assertion));
        return createUser(assertion);
    }
  &lt;/code&gt;
&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;추가-고려사항&quot;&gt;추가 고려사항&lt;/h4&gt;
&lt;h5 id=&quot;flutter-sdk를-사용하지-않고-native로-구현할-수-있을까&quot;&gt;Flutter SDK를 사용하지 않고 Native로 구현할 수 있을까?&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;물론 가능하다. api를 요청하는 방식으로 OAuth 1번 방식대로 처리할 수 있지만, 해당 구현로직을 안드로이드 IOS 모두 구현하는 것 자체가 시간이 소요될 수 있어 의사결정이 필요한 부분이라 판단함&lt;br /&gt;
&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/5df793d1-4d4c-44bd-a11f-fd9db7c22c5f.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;관련-redirect-url-처리는-어떻게-할-수-있을까&quot;&gt;관련 Redirect URL 처리는 어떻게 할 수 있을까?&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Flutter SDK에서 컨트롤하는 웹뷰 페이지에 대해서는 직접 컨트롤 할 수 있는것도 없는 것도 있음&lt;/li&gt;
  &lt;li&gt;이걸 컨트롤하는 것이 현실적으로 쉽지 않기 때문에 SDK를 사용하는 것이 편리할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;로그인-실패관련-로깅은-어떻게-하면-좋을까&quot;&gt;로그인 실패관련 로깅은 어떻게 하면 좋을까?&lt;/h5&gt;

&lt;h5 id=&quot;테스트-작성-시-무엇을-고려하면-좋을까&quot;&gt;테스트 작성 시 무엇을 고려하면 좋을까?&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;테스트의 어려움
    &lt;ul&gt;
      &lt;li&gt;외부 의존적인 테스트가 진행되어야 하기에, 테스트 흐름이 까다로움 → 해당 부분만 Mock Server를 두는 방식으로 처리하는 방식 등 염두&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;프로젝트-설정-시-고려-사항&quot;&gt;프로젝트 설정 시 고려 사항&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트를 설정할 때는 dev, stage, prod 등 환경별로 나눠서 처리하도록 한다.
    &lt;ul&gt;
      &lt;li&gt;가령 Firebase auth를 사용한다고하면 SSO 등을 제공하는데 이러한 부분들을 고려했을 때 환경별로 구분을 해두는 것이 유용해 보임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/909fdd8f-7165-448f-b27a-085f76474576.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-blog-contents.s3.ap-northeast-2.amazonaws.com/git_blog/20231110p11/5d20c4c5-99ab-4dbe-b3ce-e01c3b7b0a97.png&quot; /&gt;&lt;/p&gt;</content><author><name>Jung Hyun Shin</name></author><category term="hands-on" /><category term="Hands-on experience" /><summary type="html">로그인 프로세스 만들기 문제정의 목표 사용자가 로그인을 하기 편리한 프로세스를 확립한다. 가급적 한번의 버튼 클릭으로 로그인을 할 수 있다. 데이터 분석 목적으로 사용자의 정보를 최대한 많이 수집할 수 있는 로그인 수단을 고려한다. 하나의 Auth 서버를 사용하여 여러개의 서비스를 로그인 할 수 있도록 설계한다.</summary></entry><entry><title type="html">Hands-on.Write procedures well in postgresql</title><link href="http://localhost:4000/postgresql-procesure" rel="alternate" type="text/html" title="Hands-on.Write procedures well in postgresql" /><published>2023-10-27T00:00:00+09:00</published><updated>2023-10-27T00:00:00+09:00</updated><id>http://localhost:4000/postgresql-procesure</id><content type="html" xml:base="http://localhost:4000/postgresql-procesure">&lt;div class=&quot;highlight&quot;&gt; TODO 입니다. &lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;목차&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로시저에 대해서&lt;/li&gt;
  &lt;li&gt;업무에서 효율적으로 쓴 경험&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jung Hyun Shin</name></author><category term="hands-on" /><category term="Hands-on experience" /><summary type="html">TODO 입니다.</summary></entry><entry><title type="html">Hands-on.Push Service. How to Do that?</title><link href="http://localhost:4000/push-architecture" rel="alternate" type="text/html" title="Hands-on.Push Service. How to Do that?" /><published>2023-09-03T00:00:00+09:00</published><updated>2023-09-03T00:00:00+09:00</updated><id>http://localhost:4000/push-architecture</id><content type="html" xml:base="http://localhost:4000/push-architecture">&lt;div class=&quot;highlight&quot;&gt; TODO 입니다. &lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;목차&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;푸시에 대해서&lt;/li&gt;
  &lt;li&gt;푸시를 보내는 여러가지 방법 서칭&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jung Hyun Shin</name></author><category term="theory" /><category term="knowledge sharing" /><summary type="html">TODO 입니다.</summary></entry><entry><title type="html">Hands-on.Getting started with Flutter</title><link href="http://localhost:4000/flutter" rel="alternate" type="text/html" title="Hands-on.Getting started with Flutter" /><published>2023-08-15T00:00:00+09:00</published><updated>2023-08-15T00:00:00+09:00</updated><id>http://localhost:4000/flutter</id><content type="html" xml:base="http://localhost:4000/flutter">&lt;div class=&quot;highlight&quot;&gt; TODO 입니다. &lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;목차&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;앱개발&lt;/li&gt;
  &lt;li&gt;플러터의 이해&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jung Hyun Shin</name></author><category term="hands-on" /><category term="Hands-on experience" /><summary type="html">TODO 입니다.</summary></entry><entry><title type="html">Hands-on.Manage image resources well with S3 and CloudFront and Waf</title><link href="http://localhost:4000/images" rel="alternate" type="text/html" title="Hands-on.Manage image resources well with S3 and CloudFront and Waf" /><published>2023-07-21T00:00:00+09:00</published><updated>2023-07-21T00:00:00+09:00</updated><id>http://localhost:4000/images</id><content type="html" xml:base="http://localhost:4000/images">&lt;div class=&quot;highlight&quot;&gt; TODO 입니다. &lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;목차&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;s3 이미지 처리 관련 경험담&lt;/li&gt;
  &lt;li&gt;어찌하면 좋을까?&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jung Hyun Shin</name></author><category term="hands-on" /><category term="Hands-on experience" /><summary type="html">TODO 입니다.</summary></entry><entry><title type="html">Hands-on.Improve Login Process</title><link href="http://localhost:4000/login-part-one" rel="alternate" type="text/html" title="Hands-on.Improve Login Process" /><published>2023-06-21T00:00:00+09:00</published><updated>2023-06-21T00:00:00+09:00</updated><id>http://localhost:4000/login-part-one</id><content type="html" xml:base="http://localhost:4000/login-part-one">&lt;div class=&quot;highlight&quot;&gt; TODO 입니다. &lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;목차&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;로그인 개선기&lt;/li&gt;
  &lt;li&gt;로그인에 대해서&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jung Hyun Shin</name></author><category term="hands-on" /><category term="Hands-on experience" /><summary type="html">TODO 입니다.</summary></entry><entry><title type="html">Theory.Is the CDC &amp;amp; Debeziumev necessary for our organization?</title><link href="http://localhost:4000/cdc-debezium" rel="alternate" type="text/html" title="Theory.Is the CDC &amp;amp; Debeziumev necessary for our organization?" /><published>2023-05-21T00:00:00+09:00</published><updated>2023-05-21T00:00:00+09:00</updated><id>http://localhost:4000/cdc-debezium</id><content type="html" xml:base="http://localhost:4000/cdc-debezium">&lt;div class=&quot;highlight&quot;&gt; TODO 입니다. &lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;목차&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CDC란?&lt;/li&gt;
  &lt;li&gt;솔루션&lt;/li&gt;
  &lt;li&gt;사례&lt;/li&gt;
  &lt;li&gt;우리조직에 필요할까?&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jung Hyun Shin</name></author><category term="theory" /><category term="knowledge sharing" /><summary type="html">TODO 입니다.</summary></entry><entry><title type="html">Hands-on.Introduction to React programming</title><link href="http://localhost:4000/react-programing" rel="alternate" type="text/html" title="Hands-on.Introduction to React programming" /><published>2023-05-06T00:00:00+09:00</published><updated>2023-05-06T00:00:00+09:00</updated><id>http://localhost:4000/react-programing</id><content type="html" xml:base="http://localhost:4000/react-programing">&lt;div class=&quot;highlight&quot;&gt; TODO 입니다. &lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;목차&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프론트엔드 개발을 시작하면서&lt;/li&gt;
  &lt;li&gt;좌충우돌 front 개발기&lt;/li&gt;
  &lt;li&gt;제일먼저 찾아본 지식들&lt;/li&gt;
  &lt;li&gt;앞으로 프론트를 어떻게 해나갈 것인가?&lt;/li&gt;
  &lt;li&gt;feat. full stack이란 무엇인가?&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jung Hyun Shin</name></author><category term="hands-on" /><category term="Hands-on experience" /><summary type="html">TODO 입니다.</summary></entry><entry><title type="html">Hands-on.Extract statistical information with JPA QueryDsl</title><link href="http://localhost:4000/query-dsl" rel="alternate" type="text/html" title="Hands-on.Extract statistical information with JPA QueryDsl" /><published>2023-04-02T00:00:00+09:00</published><updated>2023-04-02T00:00:00+09:00</updated><id>http://localhost:4000/query-dsl</id><content type="html" xml:base="http://localhost:4000/query-dsl">&lt;div class=&quot;highlight&quot;&gt; TODO 입니다. &lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;목차&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;QueryDsl에 대해서&lt;/li&gt;
  &lt;li&gt;실무 이야기 잠깐해주고&lt;/li&gt;
  &lt;li&gt;QueryDsl 사용하면서 꿀팁&lt;/li&gt;
  &lt;li&gt;통계정보에 QueryDsl 적용&lt;/li&gt;
  &lt;li&gt;후기 장단점&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jung Hyun Shin</name></author><category term="hands-on" /><category term="Hands-on experience" /><summary type="html">TODO 입니다.</summary></entry></feed>